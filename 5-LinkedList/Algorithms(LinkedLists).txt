FINDING MIDDLE NODE OF LINKED LISTS:
eg : 3rd element in case of n = 5
     4th element in case of n = 6 ans so on 
hence , the general tern is Middle Term = ((n/2) + 1)th term.
Naive approach  :
Calculating the length and then then traversing to ((n/2)+1)th term.
PesudoCode for approach :
temp = head;
cnt = 0;
while(temp!= NULL){
   cnt++;
   temp = temp->next;
}
MidNode = (cnt/n) + 1;
temp = head;
while(temp!=NULL){
  MidNode = MidNode - 1;
  if(MidNode == 0) break;
  temp = temp -> next;
}
reuturn temp :
T.C -> O(N+N/2)
S.C -> O(1)

Optimal Approach (Hare and tortoise approach):
create two pointers Slow and Fast , slow will jump one position and fast will jump 2 positions,
example :
1 2 3 4 5
s
f
1 2 3 4 5
  s f
1 2 3 4 5 
    s   f (Break when f reaches last element and return s as mid)
           **f reaches at the last element in case if odd elements
For even number of elements :
1 2 3 4 5 6 
s
f 
1 2 3 4 5 6
  s f
1 2 3 4 5 6
    s   f
1 2 3 4 5 6 
      s     f (f reaches null hence return s as the midpoint)
               **f reaches null in case of Even no of elements
Pseudocode :
slow = head;
fast = head;
while(fast!=NULL && fast->next!=NULL){
  slow = slow->next;
  fast = fast->next->next;
}
T.C = O(n/2)
S.C = O(1)
code :
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;
        while(fast!=NULL && fast->next != NULL){
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
};
----------------------------------------------------------------------------------------
REVERSE A LINKED LIST :
Naive way :
Traverse and insert values into stack and then push values out :
Pesudocode :
temp = head ;
stack st;
while(temp!=NULL){
  st.push(temp->data)
  temp = temp ->next
}
temp = head ;
while(temp != NULL){
  temp -> data  = st.top();
  st.pop();
  temp = temp ->next;
}
TC = O(2N)
SC = O(N)
Better Way :
reversing the links of Linked List.
----------------------------------------------------------------------------------------------------------
Detecting a loop in Linked Linked :
Naive approach : Hashing (remembering if we went through the point)
Store <node,int> , in hashmaps
map<Node* , int> mpp;
 temp = head;
 while(temp!=NULL){
    if(mpp.find(temp))
       return true;
    else
    mpp[temp] = 1;
 temp = temp ->next;
}
return false;
T.C = O( N * 2*LOG N )// traversing through LL and inserting values in map and also finding through it.
Best Approach : Tortoise and Hare approach :
slow moves by 1 and fast moves by 2.
, if slow and fast pointers ever meet , it means that there's loop .
condition to stop : move only if fast->next != NULL and fast = NULL (It can only happen if the LL is linear and has no loops)
Pseudocode :
slow = head , fast = head;
while(fast!=NULL && fast->next!=NULL){
  slow = slow->next;
  fast = fast->next->next;
     if(slow == fast) return true;
  }
return false;
code :
bool hasCycle(ListNode *head) {
        ListNode* slow = head;
        ListNode* fast = head;
        while(fast!=NULL && fast->next != NULL){
            slow = slow->next;
            fast = fast->next->next;
            if(slow == fast) return true;
        }
        return false;
-------------------------------------------------------------------------------------------------------------------------------
Detecting the starting point of loop :
Naive approach :
Hashing , store all nodes and values the moment we find the node again , its the starting point and if not , its linear LL.
Pseudocode :
map<Node* , int> mpp
Node* temp = head;
while(temp){
   if(mpp.find(temp)) return temp;
   else (mpp[temp] = 1)
 temp = temp->next;
}
return NULL;
T.C = O(N* 2* (MAP'S COMPLEXITY)
SC = O(N)
Best Approach : Tortoise and Hare Algorithm ;
Detect a loop using the approach and after loop is detected , send one pointer to the head and
move both the pointer by 1 , the point they meet is the starting point of loop :
Pseudocode :
slow = head , fast = head;
while(fast!= NULL && fast->next!=NULL){
    slow = slow -> next;
    fast = fast ->next ->next ;
    if (slow == fast ) {
        slow = head;
        while(slow!=fast){
          slow = slow->next;
          fast = fast->next;
        }
     return slow;
    }
  } 
return NULL;
 
----------------------------------------------------------------------------------------------------------
Reversing a Linked List using recursion.
Break the problem into smaller problems , this is how recursion works,
1 -> 2 -> 3 -> 4
If LL has one node(base case) : return the node itself,
pseudocode :  
     if(head == NULL || head->next == NULL)
        return head;
If LL has two nodes:
   3->4
   reversed : X<-3<-4
   3     4 
  head  front
  front->next = head;
  head->next = NULL;
  return front;(this is the new head)
If LL has 3 nodes :
  2->3->4
  2    3      4
 head front  newhead
    call sub problem for 2 nodes :
  2-> X<-3<- 4
front->next = head ;
head -> next = NULL;
return newhead;
If LL has 4 nodes ,
1 -> X<-2<-3<-4
head front   newhead

reverse(head)
  { 
    if(head == NULL || head->next == NULL)
        return head;
   Node* newhead = reverse(head->next);
   Node* first = head->next;
   front->next = head;
   head->next = NULL;
   return newhead;
}
T.C = O(N)
S.C = O(N){recursion uses stack space}
-----------------------------------------------------------------------------------------
Finding the length of a loop :
Naive method to find it would be using hashinf , traverse through each Node and increse count ,
if we revisit the node , Subtract current count with the count we viisted it the last time and hence,
we will find the length of the loop .
PesudoCode:
map<Node, int > mpp  temp = head;
int timer = 1;
while(temp!= NULL){
   if(mpp.find(temp) == NULL){
    value = mpp[temp];
    return timer- value;
   }
   mpp[temp] = timer;
   timer++;
   temp = temp->next;
}
return 0;
}
T.C = O(N * X) x = Log N or O(1) depends on the complexity of map.
S.C = o(N)
Best Approach : Tortoise and hare algorithm:
Move slow by 1 and fast by 2 , when they collide we know that there's a loop,
now keep slow stagnant and move the fast pointer by 1 and remember the count, when it meets slow again
return the count.
pseudocode:
slow = fast = head;
while(fast!=NULL && fast->next!= NULL){
  slow = slow->next;
  fast = fast->next->next;
  if(slow == fast) return findLength(slow,fast);
}
return false; 
findLength(slow,fast){
  cnt = 1 , fast = fast->next ;
  while(slow!= fast ){
    cnt++;
    fast = fast->next;
  }
  return cnt;
}
code :
int FindLength(Node* slow , Node* fast){
    int cnt = 1 ;
    fast = fast->next;
    while(fast != slow){
        cnt++;
        fast = fast->next;
    }
    return cnt;
}
int countNodesinLoop(struct Node *head)
{
    Node* slow = head;
    Node* fast = head;
    while(fast!=NULL && fast->next != NULL){
        slow = slow->next;
        fast = fast->next->next;
        if(slow == fast){
            return FindLength(slow , fast);
        }
    }
    return 0;
}
------------------------------------------------------------------------------------------



 
